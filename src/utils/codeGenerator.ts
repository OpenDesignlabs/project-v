import type { VectraProject } from '../types';

/**
 * Generates clean React/JSX code from the Vectra project tree
 * PRESERVES absolute positioning to maintain visual fidelity
 */
export const generateCode = (elements: VectraProject, rootId: string): string => {

    // Convert style object to inline style JSX string
    const styleToString = (style?: React.CSSProperties): string => {
        if (!style || Object.keys(style).length === 0) return '';

        // Keep all styles including positioning for visual fidelity
        const entries = Object.entries(style)
            .filter(([, v]) => v !== undefined && v !== null && v !== '')
            .map(([k, v]) => {
                // Handle numeric values vs string values
                const value = typeof v === 'number' ? v : `"${v}"`;
                return `${k}: ${value}`;
            });

        if (entries.length === 0) return '';
        return ` style={{ ${entries.join(', ')} }}`;
    };

    // Generate JSX for a single node
    const generateNode = (nodeId: string, indent: number): string => {
        const node = elements[nodeId];
        if (!node || node.hidden) return '';

        const spaces = '  '.repeat(indent);
        const className = node.props.className ? ` className="${node.props.className}"` : '';
        const style = styleToString(node.props.style);

        // Text
        if (node.type === 'text') {
            return `${spaces}<p${className}${style}>${node.content || ''}</p>\n`;
        }

        // Button
        if (node.type === 'button') {
            return `${spaces}<button${className}${style}>${node.content || 'Button'}</button>\n`;
        }

        // Image
        if (node.type === 'image') {
            const src = node.src || 'https://via.placeholder.com/150';
            return `${spaces}<img src="${src}"${className}${style} alt="" />\n`;
        }

        // Input
        if (node.type === 'input') {
            const placeholder = node.props.placeholder ? ` placeholder="${node.props.placeholder}"` : '';
            return `${spaces}<input${className}${placeholder}${style} />\n`;
        }

        // Icon
        if (node.type === 'icon') {
            const iconName = node.props.iconName || 'Star';
            const iconSize = node.props.iconSize || 24;
            return `${spaces}<${iconName} size={${iconSize}}${className} />\n`;
        }

        // Container types (container, canvas, grid, page, etc.)
        const hasChildren = node.children && node.children.length > 0;
        const childrenCode = hasChildren
            ? node.children!.map(childId => generateNode(childId, indent + 1)).join('')
            : '';

        if (!hasChildren) {
            return `${spaces}<div${className}${style} />\n`;
        }

        return `${spaces}<div${className}${style}>\n${childrenCode}${spaces}</div>\n`;
    };

    // Generate the full component
    const rootNode = elements[rootId];
    const componentName = rootNode?.name?.replace(/[^a-zA-Z0-9]/g, '') || 'ExportedComponent';

    // Find the canvas/artboard to export its contents
    let exportRootId = rootId;
    if (rootNode?.type === 'page' && rootNode.children?.length) {
        exportRootId = rootNode.children[0]; // Usually the canvas
    }

    const jsxContent = generateNode(exportRootId, 2);

    // Generate imports based on detected icon usage
    const iconImports = new Set<string>();
    const collectIcons = (nodeId: string) => {
        const node = elements[nodeId];
        if (!node) return;
        if (node.type === 'icon' && node.props.iconName) {
            iconImports.add(node.props.iconName);
        }
        node.children?.forEach(collectIcons);
    };
    collectIcons(exportRootId);

    const iconImportLine = iconImports.size > 0
        ? `import { ${Array.from(iconImports).join(', ')} } from 'lucide-react';\n`
        : '';

    return `import React from 'react';
${iconImportLine}
/**
 * Generated by Vectra Builder
 * Uses Tailwind CSS for styling
 */
export default function ${componentName}() {
  return (
${jsxContent}  );
}
`;
};

/**
 * Copy text to clipboard
 */
export const copyToClipboard = async (text: string): Promise<boolean> => {
    try {
        await navigator.clipboard.writeText(text);
        return true;
    } catch {
        // Fallback for older browsers
        const textarea = document.createElement('textarea');
        textarea.value = text;
        document.body.appendChild(textarea);
        textarea.select();
        document.execCommand('copy');
        document.body.removeChild(textarea);
        return true;
    }
};
